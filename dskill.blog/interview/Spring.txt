1、SpringCloud核心组件（5个）
    服务发现——Netflix Eureka客服端
        作用：实现服务治理（服务注册与发现）
        简介：Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。
        由两个组件组成：Eureka服务端和Eureka客户端。

        Eureka服务端用作服务注册中心。支持集群部署。
        Eureka客户端是一个java客户端，用来处理服务注册与发现。

        在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息。

    负载均衡——Netflix Ribbon
        作用：主要提供客户侧的软件负载均衡算法。
        简介：Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，
        可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。

        Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。
        Ribbon内置可插拔、可定制的负载均衡组件。下面是用到的一些负载均衡策略：

        简单轮询负载均衡
        加权响应时间负载均衡
        区域感知轮询负载均衡
        随机负载均衡

    断路器——Netflix Hystrix
        当微服务系统的一个服务出现故障时，故障会沿着服务的调用链路在系统中疯狂蔓延，
        最终导致整个微服务系统的瘫痪，这就是“雪崩效应”。
        为了防止此类事件的发生，微服务架构引入了“熔断器”的一系列服务容错和保护机制。

        在微服务系统中，Hystrix 能够帮助我们实现以下目标：

        保护线程资源：防止单个服务的故障耗尽系统中的所有线程资源。
        快速失败机制：当某个服务发生了故障，不让服务调用方一直等待，而是直接返回请求失败。
        提供降级（FallBack）方案：在请求失败后，提供一个设计好的降级方案，通常是一个兜底方法，当请求失败后即调用该方法。
        防止故障扩散：使用熔断机制，防止故障扩散到其他服务。
        监控功能：提供熔断器故障监控组件 Hystrix Dashboard，随时监控熔断器的状态


    服务网关——Netflix Zuul（本文以gateway取代）
        客户端发送请求，会到达网关的DispatcherHandler处理，匹配到RoutePredicateHandlerMapping。

        根据RoutePredicateHandlerMapping匹配到具体的路由策略。

        FilteringWebHandler获取的路由的GatewayFilter数组，创建 GatewayFilterChain 处理过滤请求

        执行我们的代理业务逻辑访问。


    分布式配置——Spring Cloud Config

    Spring Cloud Config 为微服务架构中的微服务提供集中化的外部配置支持，
    配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。

openfeign 什么的情况下才能用到 rollback

2、主要在项目中负责什么

2、谈谈对rpc的理解
    跨进程 也可以叫远程过程调用
    一个完整的RPC协议包含了四个组件，分别是Client、Server、Client Stub和Sever Stub。

    Client客户端表示服务的调用方。
    Sever服务端是真正的服务提供方。

    Client Stub表示客户端存根，专门用来存放服务端的地址信息，
    再将客户端的请求参数打包成网络消息，也就是序列化，然后通过网络远程发送给服务提供方。

    Server Stub表示服务端存根，用来接收客户端发送过来的消息，然后，解析消息内容，也就是反序列化，并且调用本地方法。

3、分布式事务怎么实现的

    会把一个应用系统拆分为可独立部署的多个服务，
    因此需要服务与服务之间远程协作才能完成事务操作，
    这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务

    两阶段提交又称2PC（two-phase commit protocol）,2pc是一个非常经典的强一致、中心化的原子提交协议。
    这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和N个参与者节点（partcipant）。

    准备阶段：事务协调者，向所有事务参与者发送事务内容，询问是否可以提交事务，并等待参与者回复。
    事务参与者收到事务内容，开始执行事务操作，讲 undo 和 redo 信息记入事务日志中（但此时并不提交事务）。
    如果参与者执行成功，给协调者回复yes,表示可以进行事务提交。如果执行失败，给协调者回复no,表示不可提交。

    提交阶段：如果协调者收到了参与者的失败信息或超时信息，直接给所有参与者发送回滚（rollback）信息进行事务回滚，否则，发送提交（commit）信息。
    参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意：必须在最后阶段释放锁资源) 。


    redo log的文件和undo log文件的区别

    当事务发生异常或显式回滚时，使用undo log回滚数据，即：存储的数据是修改或删除之前的数据，其数据类型以二进制blob类型存在，当回滚完成或者程序结束时，自动释放。

    redo log当然存储的是修改或者删除之后的数据啦。redo log不是随着事务提交才写入文件的，而是从事务开始就逐步写入文件了（即使事务还没提交）


4、项目中负载均衡怎么实现的

5、mq的五种模式
    简单队列
        一个生产者对应一个消费者！！
    work 模式
        一个生产者对应多个消费者，但是一条消息只能有一个消费者获得消息！！！
        轮询分发就是将消息队列中的消息，依次发送给所有消费者。一个消息只能被一个消费者获取。
    发布/订阅模式
        一个消费者将消息首先发送到交换器，交换器绑定到多个队列，然后被监听该队列的消费者所接收并消费。

        ps:X表示交换器，在RabbitMQ中，交换器主要有四种类型:direct、fanout、topic、headers，这里的交换器是 fanout。下面我们会详细介绍这几种交换器。
        　　两个消费者获得了同一条消息。即就是，一个消息从交换机同时发送给了两个队列中，监听这两个队列的消费者消费了这个消息；
        如果没有队列绑定交换机，则消息将丢失。因为交换机没有存储能力，消息只能存储在队列中。
    路由模式
        生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由key，那么消息只会发送到相应key相同的队列，接着监听该队列的消费者消费消息。

        也就是让消费者有选择性的接收消息。
        路由模式，是以路由规则为导向，引导消息存入符合规则的队列中。再由队列的消费者进行消费的。

    主题模式
        上面的路由模式是根据路由key进行完整的匹配（完全相等才发送消息），这里的通配符模式通俗的来讲就是模糊匹配。

        符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。
        　　与路由模式相似，但是，主题模式是一种模糊的匹配方式。

  这五种工作模式，可以归为三类：

  生产者，消息队列，一个消费者；
  生产者，消息队列，多个消费者；
  生产者，交换机，多个消息队列，多个消费者；


6、https的三次握手 四次挥手

    ● 第一次握手：证明了发送方能发数据
    ● 第二次握手：ACK确保了接收方能收数据，SYN确保了接收方能发数据
    ● 第三次握手：确保了发送方能收数据并能正确应答

    第一次挥手：Client发送一个FIN，ACK，确认号和序号，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
    第二次挥手：Server收到FIN后，发送一个ACK给Client，确认号为对方序号+1，Server进入CLOSE_WAIT状态。
    第三次挥手：Server发送一个FIN和ACK，序号用对方的确认号，确认号为对方序号＋1，关闭Server到Client的数据传送，Server进入LAST_ACK状态。
    第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认号为对方序号+1，Server进入CLOSED状态，完成四次挥手。


7、谈谈对tcp协议
    是一种面向连接的、可靠的、基于字节流的传输层通讯协议。
    TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收

8、分布式锁 （看门狗）

    面试官：请问你用 Redis 做分布式锁的时候，如果指定过期时间到了，把锁给释放了。
    但是任务还未执行完成，导致任务再次被执行，这种情况你会怎么处理呢？

    程序保证调用 unlock 方法没毛病，这是在程序层面可控、可保证的。
    但是如果你程序运行的服务器刚好还没来得及执行 unlock 就宕机了呢，这个你不能打包票吧？
    这个锁是不是就死锁了？

    在 Redisson 实例被关闭前，这个狗子可以通过定时任务不断的延长锁的有效期。

    因为你根本就不需要设置过期时间，这样就从根本上解决了“过期时间不好设置”的问题。
    默认情况下，看门狗的检查锁的超时时间是 30 秒钟，也可以通过修改参数来另行指定。


9、工作流 Activiti
    流程变量、流程定义、流程分类、流程指定、流程表单
    引擎service接口

    Activiti流程引擎重点关注在系统开发的易用性和轻量性上,每一项BPM业务功能Activiti流程引擎都以服务的形式提供给开发人员,通过使用这些服务,开发人员能够构建出功能丰富,轻便且高效的BPM应用程序
    activiti.cfg.xml文件为核心配置文件,该配置文件集成在Spring的IOC容器当中,可以产生ProcessEngineConfiguration对象,这个对象就是流程引擎的配置对象
    ProcessEngine对象为流程引擎对象,该对象是工作流业务系统的核心,所有的业务操作都是由这个对象所派生出来的对象实现
    Activiti引擎提供了七大Service接口,均通过ProcessEngine获取,并且支持链式API编程风格
    流程设计器

    基于Web的Activiti Modeler流程设计器
    IDEA的actiBPM插件
    原生支持Spring

    Activiti原生支持Spring,可以很轻松地进行Spring集成,非常方便管理事务和解析表达式(Expression)
    分离运行时与历史数据

    Activiti继承自jBPM4,在表结构设计方面也遵循运行时与历史数据的分离
    这样的设计可以快速读取运行时数据,仅当需要查询历史数据时再从专门的历史数据表中读取.这种设计方式可以大幅提高数据的存取效率,尤其是当数据日积月累时依然能够快速反应


10、认证服务 JWT

    支持跨域访问，Cookie是不允许跨域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.

    无状态:Token机制在服务端不需要存储session信息，因为Token自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.

    解耦 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.

    适用性更广：只要是支持http协议的客户端，就可以使用token认证。

    服务端只需要验证token的安全，不必再去获取登录用户信息，因为用户的登录信息已经在token信息中。

    基于标准化:你的API可以采用标准化的 JSON Web Token (JWT).

11、数据权限 越权处理 防止越权

12、MQ主要是做什么工作
    应用解耦：
    当 A 系统生产关键数据，发送数据给多个其他系统消费，此时 A 系统和其他系统产生了严重的耦合，
    如果将 A 系统产生的数据放到 MQ 当中，其他系统去 MQ 获取消费数据，此时各系统独立运行只与 MQ 交互，
    添加新系统消费 A 系统的数据也不需要去修改 A 系统的代码，达到了解耦的效果。

    异步处理：
    互联网类企业对用户的直接操作，一般要求每个请求在 200ms 以内完成。对于一个系统调用多个系统，
    不使用 MQ 的情况下，它执行完返回的耗时是调用完所有系统所需时间的总和；使用 MQ 进行优化后，
    执行的耗时则是执行主系统的耗时加上发送数据到消息队列的耗时，大幅度提升系统性能和用户体验。

    流量削峰：
    MySQL 每秒最高并发请求在 2000 左右，用户访问量高峰期的时候涌入的大量请求，
    会将 MySQL 打死，然后系统就挂掉，但过了高峰期，请求量可能远低于 2000，
    这种情况去增加服务器就不值得，如果使用 MQ 的情况，将用户的请求全部放到 MQ 中，让系统去消费用户的请求
    ，不要超过系统所能承受的最大请求数量，保证系统不会再高峰期挂掉，高峰期过后系统还是按照最大请求数量处理完请求。

 如何保证消息消费的幂等性？防止消费者重复消费消息

   消费者重复消费的场景：当mq向消费者发送消息，消费者收到消息了会返回一个请求。如果没有收到消息就会重复推送消息，也可能向另外集群里面的消费者推送。①网络超时，导致mq重复发消息，消费者消费多次消息；②本地事务的执行时长比mq的长。

   所有MQ产品并没有提供主动解决幂等性的机制，需要由消费者自行控制。
   RocketMQ：给每个消息分配了个MessagelD。这个MessagelD就可以作为消费者判断幂等的依据。MessagelD不能保证全局唯一，这种方式不太建议。
   最好的方式就是自己带一个有业务标识的1D，来进行幂等判断。比如订单OrderId；
   或者用redis生产id统一ID分配。


 怎么防止消息丢失？
   RabbitMQ：①消息发送＋回调；②手动事务：channel.txSelect（）开启事务，channel.txCommito提交事务，channell.txRollback（）回滚事务。
   这种方式对channel是会产生阻塞的，造成吞吐量下降。③Publisher Confirm。整个处理流程跟RocketMQ的事务消息，基本是一样的。

13、用到过那些设计模式
    单例模式
    原型模型
        补充，深拷贝的实现方式：
        方法1：可以将其转成json，然后再转换回来
        方法2：若不方便转为json，可以将其序列化，然后再反序列化。
    工厂模式
        简单工厂模式
        工厂方法模式
        抽象工厂模式

        简单工厂：所有的产品都由一个工厂生产。如果你想加产品，就改源代码。
        工厂方法：有多个工厂，但一个工厂只生产一种产品。如耐克厂只生产耐克鞋，阿迪厂只生产阿迪鞋。如果你想加产品，那就加工厂类。
        抽象工厂：有多个工厂，每个工厂可以生产多类产品。如耐克厂可以生产耐克鞋和耐克衣服，阿迪厂可以生产阿迪鞋和阿迪衣服。但如果你想生产帽子，那么就需要在抽象工厂里加抽象方法，然后修改所有的子类。
    建造者模式（Builder）


14、谈谈面向对象的理解
    面向对象的三大特性：封装、继承和多态。
    封装 通过访问修饰符（如 private）来修饰成员变量和成员方法，将不需要对外提供的内容都隐藏起来，提供公共方法对其访问。
    继承 继承主要用途是将子类存在共性的东西，把它抽取出来放到父类里面，比如将共同拥有的属性和方法抽取出来放到父类里面。
    多态 多态是和继承一脉相承的，多态存在的需要有三个必要条件：继承、重写、父类引用指向子类对象。


15、小数精度丢失问题
    计算机是使用二进制存储数据的
    对小数点以后的数乘以2，会得到一个结果，取结果的整数部分(不是1就是0)，
    然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了。
    顺序取每次运算得到的整数部分，即为转换后的小数部分。
    如0.1。

16、数据库基础类型


17、索引遵循什么原则
        选择唯一性索引
        为经常需要排序、分组和联合操作的字段建立索引
        为常作为查询条件的字段建立索引
        限制索引的数目
        尽量使用数据量少的索引
        尽量使用前缀来索引
        删除不再使用或者很少使用的索引
        最左前缀匹配原则，非常重要的原则。
        尽量选择区分度高的列作为索引。
   索引失效
        模糊查询:like '%'；like '%%'通配符放在开头会导致索引失效。会进行全表扫描
        数据类型发生转换：当字符类型没有使用引号的时候，mysql会自动将字符转换成数字，
            会用到隐式转换，相当于使用了函数。（但是在8.0函数索引中会不会有效，还没研究）
        多列组成组合索引：需要遵循最左匹配原则，从索引最左侧顺序进行检索，在组合索引中是按照列的顺序进行存储的，所以查的时候也需要按照顺序查。
        索引列使用运算符，！=或者not：类似使用函数。
        多表连接查询没有正确使用mysql规则，也会导致索引失效。


   索引是基于什么实现的
       Mysql的InnoDB引擎里主要有主键索引和普通索引类型，底层采用的是B+树的数据结构存储数据，
       而 B+树中的数据是存储在叶子节点，子节点存储索引，并且通过链表的方式把叶子节点中的数据进行连接。
       正确的使用索引会提高sql的查询效率，当需要对sql进行优化的时候，
       可以在当前的sql前加上explain关键字，查看当前sql的执行计划，通过type字段是否为ALL，
       key字段是否为空检查是否索引命中。适当优化sql的查询结构，提升查询效率。

18、maven排查依赖冲突

19、springBoot常用注解

20、springBoot 包扫描 加载到IOC容器

21、线程安全问题

22、事物的隔离级别
   数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。
   而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。
   Read uncommitted(读未提交)
    读未提交，就是一个事务可以读取另一个未提交事务的数据。
   Read committed(读提交)
    读提交，就是一个事务要等另一个事务提交后才能读取数据。
   Repeatable read(重复读)
    重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。
   Serializable （序列化）

23、事务特性 ACID

    Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
    事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

    Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
    这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

    Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
    事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

    Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

24、sql注入问题
    mybatis 提供了两种方式 #{} 和 ${}

    当用户使用${param}进行参数传递时,表示使用拼接字符串的方式进行参数的注入

    会将接受到参数的内容不加任何修饰符拼接在 SQL 中，将引起 SQL 注入问题。

25、mybatis 一级缓存和二级缓存
    一级缓存作用域是sqlsession级别的，同一个sqlsession中执行相同的sql查询（相同的sql和参数），第一次会去查询数据库并写到缓存中，第二次从一级缓存中取。

    一级缓存是基于 PerpetualCache 的 HashMap 本地缓存，默认打开一级缓存。


    它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。

    二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。


26、mybatis-plus 规范 标签 动态标签

27、es有没有使用过

28、linux 有没有操作过  cpu过高 排查

    top命令，然后按shift+p按照CPU排序 -- 找到占用CPU过高的进程的pid
    top -H -p [进程id] 找到进程中消耗资源最高的线程的id

    第三步：使用
    echo ‘obase=16;[线程id]’ | bc或者printf “%x\n” [线程id]
    将线程id转换为16进制（字母要小写）
    bc是linux的计算器命令

    第四步：执行
    jstack [进程id] |grep -A 10 [线程id的16进制]”


29、OOM 排查

    堆溢出
    其实，大部分OOM场景都是堆溢出，也就是对象满了，来不及GC，内存溢出不够分配了。
    那么堆中存放的又是什么呢？当然是实例对象

    一个原因可能是代码中有人写了死循环创建对象，导致一瞬间创建的对象太多了
    还有个原因就是某个对象的内存占用无限增长，发生了内存泄漏。比如某个service中使用了ThreadLocal但是事后没有remove，导致它维护的ThreadLocalMap越来越大。最终溢出。


30、如何进入docker
    sudo docker ps
    sudo docker exec -it 775c7c9ee1e1 /bin/bash

31、缓存在项目中怎么使用的


