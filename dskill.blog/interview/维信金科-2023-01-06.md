维信金科 JAVA面试 2023-01-06

- 自我介绍

> 面试官 你好, 我叫xxx，xx年毕业于xxxxx大学，目前从事4年多的JAVA开发，1年多的项目管理，并按质按量完成过三个项目的开发，善于钻研，需求设计并基于可行性方案落地实现、项目reviewCode等,先简单介绍到这里，面试官看看您有什么问题，我可以再补充。

- 两家公司哪家对你的成长比较高? 更偏向管理还是技术?

> 第二家，因为最近一个项目，担任了小组组长，并顺利交付，在期间也是重点培养自己
>- 多维度思考能力
   >  > - 代码暂停思维：假如非原子性代码运行到某一行暂停，其他线程重新操作是否会出问题
   >  > - 时间扩大思维：1纳秒的时间，扩大到1分钟，代码逻辑是否会有问题
>- 专业技术能力
   >  > 技术Leader的立身之本，肯定需要不断精进，如果技不如人，是无法服众的。
>- 业务理解能力
   >  > 对业务有正确的理解，甚至能理解到业务的本质需求，才能让技术实现价值。
>- 任务分解能力
   >  > 承担着开发任务分解分配的职责，如果分解不当，漏掉了一些环节，
   > 就会导致任务的延迟、质量的不可控，为项目带来了风险。
>- 时间管理能力
   >  > 需要在有限的时间里高效地管理多种事情，自然就需要提高时间管理能力。
>- 深度思考能力
   >  > 深度思考能力越强的人，越能看到问题的本质，各方面的能力也会越优秀。
>- 团队建设能力
   >   >
   >   >  - 人员培训
            - 了解每个人的职业规划，为他们的职业发展路线提出建议，并在工作中不断给他们提供成长的机会，注重于他们的成长，以提高团队整体的技术水平。
   >   >  - 项目规范
            - 要制定适合团队和项目情况的管理规范，并在实践中再不断去优化演进。
   >   >  - 每日例会
            - 目的主要是同步项目进度，发言要简明扼要、关注重点、禁止报流水账， 可提出问题，但切记不要在例会中讨论解决问题，例会后再去沟通解决。
   >   >  - 复盘总结
            - 每次版本迭代结束后，应该组织复盘总结会，这很重要，总结成功经验，吸取失败教训，有助于提升团队能力。
   >   >  - 质量管理
            - 贯穿整个研发流程中每一个阶段,主要包括测试驱动开发、设计评审、code review 等
>   >
>- 向上管理能力
   >  > 向上管理不妨站在老板的角度考虑问题，换位思考并保持同理心。保持同频沟通，多反馈，多进行非正式的沟通，增强彼此之间的信任感。
>- 领导力
   >  > - 最核心的一点就是要懂得授人以渔，教以方法论。
   >  > - 领导力不同于管理力，不能靠职权，而是靠个人魅力。
   >  > - 技术人员更喜欢被“领导”，而不是被“管理”。
   >  > - 管理的本质，是激发人的善意和潜能。

- 离职的原因

>寻求大一点的平台，以方便更快提高自己的技术水平

- JAVA 反射机制

  >- 如何反射获取 Class 对象
  >
  >  ```java
  >  // 1.通过字符串获取Class对象，这个字符串必须带上完整路径名
  >  Class studentClass = Class.forName("com.test.reflection.Student");
  >  // 2.通过类的class属性
  >  Class studentClass2 = Student.class;
  >  // 3.通过对象的getClass()函数
  >  Student studentObject = new Student();
  >  Class studentClass3 = studentObject.getClass();
  >  ```
  >
  >- 如何反射获取类中的所有字段
  >
  >  ```java
  >  // 1.获取所有声明的字段
  >  Field[] declaredFieldList = studentClass.getDeclaredFields();
  >  for (Field declaredField : declaredFieldList) {
  >      System.out.println("declared Field: " + declaredField);
  >  }
  >  // 2.获取所有公有的字段
  >  Field[] fieldList = studentClass.getFields();
  >  for (Field field : fieldList) {
  >      System.out.println("field: " + field);
  >  }
  >  ```
  >
  >- 如何反射获取类中的所有构造方法
  >
  >  ```java
  >  // 1.获取所有声明的构造方法
  >  Constructor[] declaredConstructorList = studentClass.getDeclaredConstructors();
  >  for (Constructor declaredConstructor : declaredConstructorList) {
  >      System.out.println("declared Constructor: " + declaredConstructor);
  >  }
  >  // 2.获取所有公有的构造方法
  >  Constructor[] constructorList = studentClass.getConstructors();
  >  for (Constructor constructor : constructorList) {
  >      System.out.println("constructor: " + constructor);
  >  }
  >  ```
  >
  >- 如何反射获取类中的所有非构造方法
  >
  >  ```java
  >  // 1.获取所有声明的函数
  >  Method[] declaredMethodList = studentClass.getDeclaredMethods();
  >  for (Method declaredMethod : declaredMethodList) {
  >      System.out.println("declared Method: " + declaredMethod);
  >  }
  >  // 2.获取所有公有的函数
  >  Method[] methodList = studentClass.getMethods();
  >  for (Method method : methodList) {
  >      System.out.println("method: " + method);
  >  }
  >  ```
  >
  >- Field 类：提供有关类的属性信息，以及对它的动态访问权限。它是一个封装反射类的属性的类。
  >- Constructor 类：提供有关类的构造方法的信息，以及对它的动态访问权限。它是一个封装反射类的构造方法的类。
  >- Method 类：提供关于类的方法的信息，包括抽象方法。它是用来封装反射类方法的一个类。
  >- Class 类：表示正在运行的 Java 应用程序中的类的实例。
  >- Object 类：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。

- JVM 的调优

      通用GC参数    
          -Xmn：年轻代大小   -Xms：堆初始大小  -Xmx：堆最大大小  -Xss：栈大小
      
          -XX:+UseTlab：使用tlab，默认打开，涉及到对象分配问题
      
          -XX:+PrintTlab：打印tlab使用情况
      
          -XX:+TlabSize：设置Tlab大小
      
          -XX:+DisabledExplictGC：java代码中的System.gc()不再生效，防止代码中误写，导致频繁触动GC，
          默认不起用。
      
          -XX:+PrintGC(+PrintGCDetails/+PrintGCTimeStamps)打印GC信息(打印GC详细信息/打印GC执行时
          间)
      
          -XX:+PrintHeapAtGC打印GC时的堆信息
      
          -XX:+PrintGCApplicationConcurrentTime 打印应用程序的时间
      
          -XX:+PrintGCApplicationStopedTime 打印应用程序暂停时间
      
          -XX:+PrintReferenceGC 打印回收多少种引用类型的引用
      
          -verboss:class 类加载详细过程
      
          -XX:+PrintVMOptions 打印JVM运行参数
      
          -XX:+PrintFlagsFinal(+PrintFlagsInitial)  -version | grep 查找想要了解的命令，很重要
      
          -X:loggc:/opt/gc/log/path  输出gc信息到文件
      
          -XX:MaxTenuringThreshold  设置gc升到年龄，最大值为15
          
          
      parallel常用参数
          -XX:PreTenureSizeThreshold 多大的对象判定为大对象，直接晋升老年代
      
          -XX:+ParallelGCThreads 用于并发垃圾回收的线程
      
          -XX:+UseAdaptiveSizePolicy 自动选择各区比例
          
          
      CMS常用参数
          -XX:+UseConcMarkSweepGC 使用CMS垃圾回收器
      
          -XX:parallelCMSThreads CMS线程数量
      
          -XX:CMSInitiatingOccupancyFraction 占用多少比例的老年代时开始CMS回收，默认值68%，如果频繁发生serial old，适当调小该比例，降低FGC频率
      
          -XX:+UseCMSCompactAtFullCollection 进行压缩整理
      
          -XX:CMSFullGCBeforeCompaction 多少次FGC以后进行压缩整理
      
          -XX:+CMSClassUnloadingEnabled 回收永久代
      
          -XX:+CMSInitiatingPermOccupancyFraction 达到什么比例时进行永久代回收
      
          GCTimeTatio 设置GC时间占用程序运行时间的百分比，该参数只能是尽量达到该百分比，不是肯定达到
      
          -XX:MaxGCPauseMills GCt停顿时间，该参数也是尽量达到，而不是肯定达到
          
      
      G1常用参数
          -XX:+UseG1 使用G1垃圾回收器
      
          -XX:MaxGCPauseMills GCt停顿时间，该参数也是尽量达到，G1会调整yong区的块数来达到这个值
      
          -XX:+G1HeapRegionSize 分区大小，范围为1M~32M，必须是2的n次幂，size越大，GC回收间隔越大，
          但是GC所用时间越长
      
          G1NewSizePercent 新生代所占最小比例，默认5%
      
          G1MaxNewSizePercent 新生代所占最大比例，默认60%
      
          GCTimeRatio GC时间比例，此值为建议值，G1会调整堆大小来尽量达到这个值
      
          ConcGCThreads GC线程数量
      
          InitiatingHeapOccupancyPercent 启动G1的堆空间占用比例
  

- HashMap的数据结构？扩容机制？成员变量？

  > 1. 存储 key - value 类型结构，数据类型不限制
  >
  > 2. 根据 key 的 hashcode 值进行存储数据
  >
  > 3. 最多只允许一条记录的键(key)为 null（对 value 值不约束）
  >
  > 4. 它是无序的（其实一见 hash 我们便知道了）
  >
  > 5. 查询效率很高
  >
  > 6. 它是线程不安全的（要线程安全，可以使用 Collections 的 synchronizedMap，或者使用更加推荐的 ConcurrentHashMap）
  >
  >    兄弟姐妹 LinkedHashMap、TreeMap、Hashtable 、ConcurrentHashMap
  >
  > **如果阈值大于8，但是数组长度小64，此时并不会将链表变为红黑树。而是选择进行数组扩容**
  >
  > **红黑树是在 JDK1.8 版本才引入的，目的是加快链表的查询效率** 
  >
  > **初始容量是 16，可以扩容，但是扩容之后的容量，也是 2 的幂次方**
  >
  > 

- 线程池的原理

  

- nio bio的区别

  

- 缓存的雪崩问题

  

- 数据库的优化 怎么设计表结构

  

- 项目中cpu飙高 OOM排查

  

- 处理几十万数据计算怎么处理

  

- 数据库有一年的数据，按天做计算，怎么实现

  

- 个人的职业规划

